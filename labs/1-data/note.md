# Data-lab

Ubuntu 64-bit上先要装一下32位的库
```
> sudo apt-get install gcc-multilib
```

## Ingteger 表达式规则:

只能使用：
1. int常量 只能 [0, 255] (1 Byte)
2. local variables(不能全局)
3. 单目运算符只能用 `!`, `~`
4. 双目运算符只能用 `&`, `^`, `|`, `+`, `<<`， `>>`

禁止使用：
1. 任何控制语句 (if, while, for...)
2. macro
3. 定义额外函数或调用函数
4. 使用其他运算符 比如 `&&,` `||,` `-,` `?`
5. casting
6. 使用非int数据类型 (包括符合类型比如array)

使用`dlc`检查程序是否符合规则，加`-e`会输出每个函数使用的运算符数量
```sh
unix> ./dlc bits.c
```

检查运行结果是否正确
```sh
unix> make btest
unix> ./btest [optional cmd line args]
```

`ishow` `fshow` 是辅助工具，可以显示整数或浮点数的二进制表示

## Integer笔记

`bitXor`:
- 用 `&` 和 `~` 构造 异或 `^`
- 将 `&` 和 `~` 对各种组合的结果列个表就很清晰了

`isTmax`:
- 思路: 尽量让Tmax变成0，其他数变成1
- `[Tmax] + 1 + [Tmax] = [-1] = ~[0]`
- 这题最难在于要排除 `-1` 的干扰，因为计算起来性质和 `Tmax` 很像，但幸运的是 `[-1] + 1 = [0]`，其他数这样做都为非0，再取非就能得到0、1，最后加上这个值就行

`isAsciiDigit`:
- 构造出upper_bound和lower_bound，使不同区间与这个bound相加会出现符号的变换
- **但是溢出的情况没有想清楚，要按区间逐个枚举才行**，记为TODO吧，这个没那么重要

`isLessOrEqual`:
- 一开始的思路： `x<=y => y-x>=0 => y+(~x+1)>=0`
- 会有异常情况：`x = -2147483648[0x80000000], y = 2147483647[0x7fffffff]`，**关键就在于 `x=0x80000000`时有`~x+1=x`，配合任何`y>=0`的数都会异常。但另一方面，假如`x=0x80000000`，同时`y`也是个负数，用`y+(~x+1)`反而会由于两次溢出而负负得正**
- 因此我们可以把符号不同的情况单独拿出来，只有当`x<0 && y >=0`时成立
- > 这道题意在指引我们怎么用布尔代数构造比较运算符，要格外留意的就是 `0x80000000` 这个值产生的异常情况

`logicalNeg`:
- > 这个没有很好的思路，但是这个取非的实现很关键!
- 有 `~0+1=0`, 还有 `~Tmin+1=Tmin`, 其他数则互为相反数(符号位会变)
- 因此可以利用 **位或** + **符号位**: 观察可知只有 `0` 进行这个运算时符号位保持为0，别的都为1，那么有 `1xxx...>>31=Tmin, 0xxx...>>31=0`，再加上1就是答案了

## 思考

- 布尔代数构造其他运算符，进而构造控制语句，挺有意思